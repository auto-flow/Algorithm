[315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

其实和逆序对差不多，就是改为对index排序（要记录下标）

和逆序对一样，在归并的统计区做数据统计，其他基本不变

```python
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:

        counts = [0] * len(nums)
        index = [i for i in range(len(nums))]

        def merge_sort(l, r):
            if l >= r:
                return
            mid = (r + l) // 2
            merge_sort(l, mid)
            merge_sort(mid + 1, r)
            # 统计
            b = mid + 1
            for a in range(l, mid + 1):
                while b <= r and nums[index[b]] < nums[index[a]]:
                    b += 1
                counts[index[a]] += b - mid - 1
            # 归并
            a = l
            b = mid + 1
            merged = []
            while a <= mid and b <= r:
                if nums[index[a]] <= nums[index[b]]:
                    merged.append(index[a])
                    a += 1
                else:
                    merged.append(index[b])
                    b += 1
            while a <= mid:
                merged.append(index[a])
                a += 1
            while b <= r:
                merged.append(index[b])
                b += 1
            index[l:r + 1] = merged

        merge_sort(0, len(nums) - 1)
        # print(index)
        return counts
```